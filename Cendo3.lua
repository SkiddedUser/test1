--[[
  CREDITS TO MECHXYZ
	mech's anitracker
	i know i suck at names

	how to use:
	1. create a new track with AnimationTrack.new()
	2. anim:setAnimation(url or table)
	3. anim:setRig(rig)
	4. anim:Play()

	- AdjustWeight doesn't actually adjust weight, it adjusts priority (i thought weights and priority were the same thing a while back)
	- set anim.lerpFactor to change how much it lerps into the next pose
	- AnimationTrack.NoDisableTransition is global and sets whether the welds lerp into their parent's Transform after all animations on a rig are done playing before being disabled, setting it to false disables the welds as soon as the last animation stops
	- welds generated by anitracker are named "AWeld" with an attribute called AnitrackerEnabled set to true, disable the welds before setting the attribute to false
	- can also be used on client
]]

local AnimationTrack
local twait = task.wait
local http = game:GetService("HttpService")
local tween = game:GetService("TweenService")

do
	AnimationTrack = {}
	AnimationTrack.Rigs = {}
	AnimationTrack.Speed = 1
	AnimationTrack.Stall = 0
	AnimationTrack.Length = 0
	AnimationTrack.Weight = 1
	AnimationTrack.Looped = false
	AnimationTrack.RealWeight = 1
	AnimationTrack.lerpFactor = .6
	AnimationTrack.TimePosition = 0
	AnimationTrack.IsPlaying = false
	AnimationTrack.__index = AnimationTrack
	AnimationTrack.NoDisableTransition = false

	local function enumExists(type, value)
		return pcall(function()
			return Enum[type][value] ~= nil
		end)
	end

	function AnimationTrack.Destroy(self)
		if not self then
			return
		end

		if self.Connections then
			for _, v in pairs(self.Connections) do
				v:Disconnect()
			end

			table.clear(self.Connections)
		end

		if self.Binds then
			for _, v in pairs(self.Binds) do
				v:Destroy()
			end

			table.clear(self.Binds)
		end

		table.clear(self.Cache)
		table.clear(self.Used)
		self.StopBind:Destroy()
		self.StopBind = nil

		local stuff = AnimationTrack.Rigs[self.Rig]

		if stuff then
			for i, v in pairs(stuff.Animations) do
				if v == self then
					stuff.Animations[i] = nil
					break
				end
			end
		end

		table.clear(self)
		self = nil
	end

	function AnimationTrack.new()
		local be = Instance.new("BindableEvent", script)

		local track = setmetatable({}, AnimationTrack)
		track.Rigs = nil

		track.Used = {}
		track.Cache = {}
		track.Binds = {}
		track.StopBind = be
		track.Connections = {}
		track.Stopped = be.Event
		track.KeyframeMarkers = {}
		track.Identifier = http:GenerateGUID()

		return track
	end

	function AnimationTrack.GetMarkerReachedSignal(self, marker)
		if not self.Binds[marker] then
			local be = Instance.new("BindableEvent")
			self.Binds[marker] = be
		end

		return self.Binds[marker].Event
	end

	function AnimationTrack.GetKeyframeReachedSignal(self, keyframe)
		if typeof(keyframe) == "number" then
			local num = keyframe
			keyframe = self.Animation[num]
			assert(keyframe, string.format("Keyframe #%d does not exist!", num))
		end

		assert(table.find(self.Animation, keyframe), "Keyframe does not exist!")

		if not self.Binds[keyframe] then
			local be = Instance.new("BindableEvent")
			self.Binds[keyframe] = be
		end

		return self.Binds[keyframe].Event
	end

	function AnimationTrack.AdjustWeight(self, weight)
		self.RealWeight = weight
		self.Weight = self.RealWeight
	end

	function AnimationTrack.addWeld(self, motor)
		local weld = motor:FindFirstChild("AWeld")

		if not weld then
			weld = Instance.new("Weld", motor)
			weld.C0 = motor.C0
			weld.C1 = motor.C1
			weld.Name = "AWeld"
			weld.Part0 = motor.Part0
			weld.Part1 = motor.Part1
		end

		weld:SetAttribute("AnitrackerEnabled", true)

		AnimationTrack.Rigs[self.Rig].Welds[motor.Part1.Name] = weld
		AnimationTrack.Rigs[self.Rig].Poses[motor.Part1.Name] = CFrame.new()
	end

	function AnimationTrack.setRig(self, rig)
		assert(self.Animation, "Must set Animation before setting Rig!")

		self.Rig = rig

		-- // funny variable name
		local boner = rig:FindFirstChild("InitialPoses")

		if boner then
			local root = rig:FindFirstChildWhichIsA("Bone", true):FindFirstAncestorWhichIsA("BasePart")

			if not root then
				boner = nil
				return
			end

			for _, v in pairs(boner:GetChildren()) do
				if string.find(v.Name, "_Initial") then
					repeat
						local bone = root:FindFirstChild(string.gsub(v.Name, "_Initial", ""), true)

						if not bone then
							break
						end

						bone:SetAttribute("Initial", v.Value)
					until true
				end
			end
		end

		if not AnimationTrack.Rigs[rig] then
			AnimationTrack.Rigs[rig] = {
				Poses = {},
				Welds = {},
				Animations = {self}
			}

			local animate

			animate = game:GetService("RunService").PreAnimation:Connect(function()
				if not AnimationTrack.Rigs[rig] then
					animate:Disconnect()
				end

				local allDone = true
				local usedJoints = {}

				for _, v in pairs(AnimationTrack.Rigs[rig].Animations) do
					if v.IsPlaying then
						allDone = false

						for i in pairs(v.Used) do
							usedJoints[i] = true
						end
					end
				end

				if not boner then
					for i, v in pairs(AnimationTrack.Rigs[rig].Welds) do
						repeat
							if not v.Parent then
								AnimationTrack.Rigs[rig].Welds[i] = nil
								break
							end

							local offset = AnimationTrack.Rigs[rig].Poses[i]
							offset = CFrame.new(offset.Position * rig:GetScale()) * CFrame.Angles(offset:ToEulerAnglesXYZ())

							if not allDone and usedJoints[i] then
								v.Enabled = v:GetAttribute("AnitrackerEnabled")
								v.C0 = v.Parent.C0 * offset
							elseif allDone or not usedJoints[i] then
								if not self.NoDisableTransition then
									v.C0 = v.C0:Lerp(v.Parent.C0 * v.Parent.Transform, self.lerpFactor)

									if (v.C0.Position - (v.Parent.C0 * v.Parent.Transform).Position).Magnitude <= .2 then
										v.Enabled = false

										if AnimationTrack.Rigs[self.Rig] then
											AnimationTrack.Rigs[self.Rig].Poses[i] = CFrame.new()
										end
									end
								else
									v.Enabled = false

									if AnimationTrack.Rigs[self.Rig] then
										AnimationTrack.Rigs[self.Rig].Poses[i] = v.Parent.Transform
									end
								end
							end
						until true
					end
				else
					for i, v in pairs(AnimationTrack.Rigs[rig].Welds) do
						repeat
							if not v:GetAttribute("Initial") then
								AnimationTrack.Rigs[rig].Welds[i] = nil
								break
							end

							if not allDone then
								v.CFrame = v:GetAttribute("Initial") * AnimationTrack.Rigs[rig].Poses[i]
							else
								v.CFrame = v:GetAttribute("Initial")

								if AnimationTrack.Rigs[self.Rig] then
									AnimationTrack.Rigs[self.Rig].Poses[i] = CFrame.new()
								end
							end
						until true
					end
				end
			end)

			local adder

			adder = rig.DescendantAdded:Connect(function(v)
				if not AnimationTrack.Rigs[rig] then
					adder:Disconnect()
				end

				if v:IsA("Motor6D") then
					self:addWeld(v)
				end
			end)

			AnimationTrack.Rigs[rig].Adder = adder
			AnimationTrack.Rigs[rig].Animate = animate
		else
			table.insert(AnimationTrack.Rigs[rig].Animations, self)
		end

		for _, v in pairs(rig:GetDescendants()) do
			repeat
				if boner and v:IsA("Bone") and self.Used[v.Name] then
					AnimationTrack.Rigs[rig].Welds[v.Name] = v
					AnimationTrack.Rigs[rig].Poses[v.Name] = CFrame.new()

					break
				end

				if v:IsA("Motor6D") and self.Used[v.Part1.Name] then
					self:addWeld(v)
				end
			until true
		end

		coroutine.wrap(function()
			repeat
				twait()
			until rig.Parent

			rig.Parent.ChildRemoved:Connect(function(v)
				if v == rig then
					AnimationTrack.Rigs[rig] = nil
					self:Destroy()
				end
			end)
		end)()
	end

	function AnimationTrack.getMotor(self, name)
		if self.Cache[name] then
			return self.Cache[name]
		end

		for _, v in pairs(self.Rig:GetDescendants()) do
			if v:IsA("Motor6D") and v.Part1.Name == name then
				self.Cache[name] = v
				return v
			end
		end
	end

	function AnimationTrack.setAnimation(self, anim)
		local length = 0

		if typeof(anim) == "string" then
			if game:GetService("RunService"):IsClient() then
				error("You must be on server to pass urls to setAnimation!")
			end

			anim = loadstring(http:GetAsync(anim))()
		end

		self.Animation = anim

		local found = {}

		for i, v in pairs(anim) do
			if v.tm > length then
				length = v.tm
			end

			for j, w in pairs(v) do
				repeat
					if typeof(w) ~= "table" then
						if typeof(w) == "string" then
							table.insert(self.KeyframeMarkers, {
								Name = j,
								Value = w,
								Time = v.tm
							})
						end

						break
					end

					found[j] = true
					self.Used[j] = true

					-- // taken from replay
					local o = 1

					while true do
						local next = anim[i + o]

						if next and next[j] then
							w.nx = i + o
							break
						end

						o = o + 1

						if o >= #(anim) then
							break
						end
					end
				until true
			end
		end

		self.Length = length
	end

	function AnimationTrack.IsPrioritized(self, j)
		if not AnimationTrack.Rigs[self.Rig] then
			return
		end

		if not AnimationTrack.Rigs[self.Rig].Animations then
			return
		end

		local highest = 0
		local prioritized

		for _, v in pairs(AnimationTrack.Rigs[self.Rig].Animations) do
			if v.Weight > highest and v.IsPlaying then
				prioritized = v
				highest = v.Weight
			end
		end

		if prioritized == self then
			return true
		elseif prioritized ~= self and prioritized then
			if not prioritized.Used[j] then
				local second
				local highest = 0

				for _, v in pairs(AnimationTrack.Rigs[self.Rig].Animations) do
					if v.Weight > highest and v.IsPlaying and v ~= prioritized then
						second = v
						highest = v.Weight
					end
				end

				return second == self
			end
		end
	end

	function AnimationTrack.setCFrame(self, name, cf, info)
		local weld = AnimationTrack.Rigs[self.Rig].Welds[name]
		local poses = AnimationTrack.Rigs[self.Rig].Poses

		if not info then
			AnimationTrack.Rigs[self.Rig].Poses[name] = cf
			weld.C0 = weld.Parent.C0 * cf
		else
			local start = tick()

			while (tick() - start) < info.Time and AnimationTrack.Rigs[self.Rig] and AnimationTrack.Rigs[self.Rig].Poses do
				poses[name] = poses[name]:Lerp(
					cf,
					tween:GetValue((tick() - start) / info.Time, info.EasingStyle, info.EasingDirection)
				)

				weld.C0 = weld.Parent.C0 * poses[name]
				twait()
			end
		end
	end

	function AnimationTrack.goToKeyframe(self, v, inst)
		local speed = self.Speed

		if self.Binds[v] then
			self.Binds[v]:Fire()
		end

		for j, w in pairs(v) do
			local br = false

			repeat
				if typeof(w) ~= "table" or not AnimationTrack.Rigs[self.Rig].Poses[j] then
					if typeof(w) == "string" and self.Binds[j] then
						self.Binds[j]:Fire(w)
					end

					break
				end

				if not AnimationTrack.Rigs[self.Rig].Animations then
					br = true
					break
				end

				local tm = 0
				local nx = w.nx
				local cf = w.cf

				if nx then
					cf = self.Animation[w.nx][j].cf
					tm = self.Animation[w.nx].tm - v.tm
				end

				if self:IsPrioritized(j) and (w.es == "Constant" or inst) then
					if inst and self:IsPrioritized(j) then
						AnimationTrack.Rigs[self.Rig].Poses[j] = cf
						break
					end

					local start = tick()

					coroutine.wrap(function()
						repeat
							AnimationTrack.Rigs[self.Rig].Poses[j] = cf
							twait()
						until tick() - start >= (tm / speed)
					end)()

					break
				end

				if not enumExists("EasingStyle", w.es) then
					w.es = "Linear"
				end

				coroutine.wrap(function()
					local s = tick()
					local current = AnimationTrack.Rigs[self.Rig].Poses[j]

					repeat
						twait()

						local cf = current:Lerp(cf, tween:GetValue(
							(tick() - s) / (tm / speed),
							Enum.EasingStyle[w.es],
							Enum.EasingDirection[w.ed]
							))

						if self:IsPrioritized(j) then
							AnimationTrack.Rigs[self.Rig].Poses[j] = AnimationTrack.Rigs[self.Rig].Poses[j]:Lerp(cf, math.min(self.lerpFactor * math.max(1, speed), 1))
						end
					until (tick() - s) >= (tm / speed)
				end)()
			until true

			if br then
				break
			end
		end
	end

	function AnimationTrack.Play(self, speed)
		assert(self.Rig, "Must use setRig before playing!")

		speed = speed or self.Speed

		if self.IsPlaying then
			for _, v in pairs(self.Connections) do
				v:Disconnect()
			end
		end

		self.Speed = speed
		self.IsPlaying = true
		self.Weight = self.RealWeight

		self.TimePosition = 0

		-- // just loop through all the keyframes instantly if speed is too high since it'll break
		if false then
			coroutine.wrap(function()
				repeat
					twait()

					for _, v in ipairs(self.Animation) do
						self:goToKeyframe(v, true)
						self.TimePosition = self.TimePosition + v.tm
					end

					self.TimePosition = self.Length
					task.wait(self.Stall)
				until not self.Looped

				self:Stop()
			end)()

			return
		end

		coroutine.wrap(function()
			repeat
				self.TimePosition = 0

				for _, v in ipairs(self.Animation) do
					local cnt
					local total = 0
					local time = v.tm

					cnt = game:GetService("RunService").PreAnimation:Connect(function(dt)
						total = total + dt * self.Speed

						if total >= time then
							cnt:Disconnect()
							self:goToKeyframe(v)
						end
					end)

					table.insert(self.Connections, cnt)
				end

				repeat
					self.TimePosition = self.TimePosition + twait() * self.Speed
				until self.TimePosition >= (self.Length + (self.Looped and 0 or self.Stall)) or not self.IsPlaying

				if self.TimePosition >= self.Length and not self.Looped then
					self:Stop()
				end
			until not self.Looped or not self.IsPlaying
		end)()
	end

	function AnimationTrack.Stop(self)
		if not self.IsPlaying then
			return
		end

		self.StopBind:Fire()

		self.Weight = 0
		self.IsPlaying = false

		if self.Connections then
			for _, cnt in pairs(self.Connections) do
				cnt:Disconnect()
			end
		end
	end

	function AnimationTrack.AdjustSpeed(self, speed)
		self.Speed = speed or 1
	end
end

local Players = game:GetService("Players")

-- Función para configurar el BillboardGui en el personaje del jugador
local function setupBillboardGui(character)
	local head = character:FindFirstChild("Head")
	if not head then return end

	-- Verifica si ya existe un BillboardGui y lo elimina si es necesario
	for _, child in pairs(head:GetChildren()) do
		if child:IsA("BillboardGui") then
			child:Destroy()
		end
	end

	-- Crear un BillboardGui en el personaje
	local billboardGui = Instance.new("BillboardGui")
	billboardGui.Parent = head
	billboardGui.Adornee = head
	billboardGui.Size = UDim2.new(3, 0, 1, 0)
	billboardGui.StudsOffsetWorldSpace = Vector3.new(0, 3, 0)
	billboardGui.AlwaysOnTop = true

	-- Crear un Frame para contener el texto y la barra de salud
	local frame = Instance.new("Frame")
	frame.Size = UDim2.new(1, 0, 1, 0)
	frame.BackgroundTransparency = 1
	frame.Parent = billboardGui

	-- Función para crear capas de texto
	local function createTextLayer(parent, size, transparency, color)
		local textLabel = Instance.new("TextLabel")
		textLabel.Parent = parent
		textLabel.Size = UDim2.new(1, 0, 0.8, 0)
		textLabel.BackgroundTransparency = 1
		textLabel.TextColor3 = color
		textLabel.TextSize = size
		textLabel.TextStrokeTransparency = 0
		textLabel.TextStrokeColor3 = Color3.new(0, 0, 0)
		textLabel.TextScaled = true
		textLabel.Position = UDim2.new(0, 0, 0.2, 0)
		textLabel.TextTransparency = transparency

		local uiGradient = Instance.new("UIGradient")
		uiGradient.Color = ColorSequence.new{
			ColorSequenceKeypoint.new(0, color),
			ColorSequenceKeypoint.new(1, Color3.new(0, 0, 0))
		}
		uiGradient.Transparency = NumberSequence.new{
			NumberSequenceKeypoint.new(0, transparency),
			NumberSequenceKeypoint.new(1, 1)
		}
		uiGradient.Parent = textLabel

		return textLabel
	end

	-- Crear las capas de texto
	local topLayer = createTextLayer(frame, 60, 0, Color3.fromRGB(255, 0, 0))
	local bottomLayer = createTextLayer(frame, 60, 0, Color3.fromRGB(255, 0, 0))

	-- Crear barra de salud
	local healthBarBackground = Instance.new("Frame")
	healthBarBackground.Parent = frame
	healthBarBackground.Size = UDim2.new(1, 0, 0.15, 0)
	healthBarBackground.Position = UDim2.new(0, 0, 0.85, 0)
	healthBarBackground.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
	healthBarBackground.BorderSizePixel = 0
	healthBarBackground.BackgroundTransparency = 0.5
	healthBarBackground.ClipsDescendants = true

	local healthBarCorner = Instance.new("UICorner")
	healthBarCorner.CornerRadius = UDim.new(0, 8)
	healthBarCorner.Parent = healthBarBackground

	local healthBar = Instance.new("Frame")
	healthBar.Parent = healthBarBackground
	healthBar.Size = UDim2.new(1, 0, 1, 0)
	healthBar.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
	healthBar.BorderSizePixel = 0

	local healthTextLabel = Instance.new("TextLabel")
	healthTextLabel.Parent = healthBarBackground
	healthTextLabel.Size = UDim2.new(1, 0, 1, 0)
	healthTextLabel.BackgroundTransparency = 1
	healthTextLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
	healthTextLabel.TextStrokeTransparency = 0
	healthTextLabel.TextStrokeColor3 = Color3.new(0, 0, 0)
	healthTextLabel.TextScaled = true
	healthTextLabel.Text = "100 / 100"
	healthTextLabel.TextXAlignment = Enum.TextXAlignment.Center
	healthTextLabel.TextYAlignment = Enum.TextYAlignment.Center

	-- Crear línea debajo del texto
	local line = Instance.new("Frame")
	line.Parent = frame
	line.Size = UDim2.new(1, 0, 0.05, 0)
	line.Position = UDim2.new(0, 0, 0.75, 0)
	line.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
	line.BorderSizePixel = 0

	local lineCorner = Instance.new("UICorner")
	lineCorner.CornerRadius = UDim.new(0, 8)
	lineCorner.Parent = line

	-- Función para animar la barra de salud
	local function animateHealthBar()
		local amplitude = 10
		local speed = 2

		while true do
			healthBarBackground.Rotation = math.sin(tick() * speed) * amplitude

			-- Actualizar la barra de salud basada en la salud actual del jugador
			local humanoid = character:FindFirstChildOfClass("Humanoid")
			if humanoid then
				local health = humanoid.Health
				local maxHealth = humanoid.MaxHealth
				local healthPercentage = health / maxHealth
				healthBar.Size = UDim2.new(healthPercentage, 0, 1, 0)
				healthTextLabel.Text = math.floor(health) .. " / " .. math.floor(maxHealth)
			end

			wait(0.02)
		end
	end

	-- Animación de la línea (sin animación propia)
	local function syncLineWithText()
		while true do
			-- Sincronizar la posición y rotación de la línea con la del texto
			line.Rotation = topLayer.Rotation
			line.Position = UDim2.new(0, 0, 0.75, 0)

			wait(0.01)
		end
	end

	-- Animación del texto y BillboardGui
	local function animateTextLabel()
		local amplitudeX = 1
		local amplitudeY = 0.5
		local amplitudeZ = 1
		local speedX = 1.5
		local speedY = 2
		local speedZ = 1.5

		while true do
			local offsetX = math.sin(tick() * speedX) * amplitudeX
			local offsetY = math.sin(tick() * speedY) * amplitudeY
			local offsetZ = math.sin(tick() * speedZ) * amplitudeZ
			billboardGui.StudsOffsetWorldSpace = Vector3.new(0, 3, 0) + Vector3.new(offsetX, offsetY, offsetZ)

			topLayer.Rotation = math.sin(tick() * 2) * 10
			bottomLayer.Rotation = topLayer.Rotation

			wait(0.01)
		end
	end

	-- Función para actualizar el texto aleatoriamente y rápidamente
	local function updateDistortedText()
		local fonts = {
			Enum.Font.Arcade, Enum.Font.Cartoon, Enum.Font.Code, Enum.Font.Fantasy, 
			Enum.Font.GothamBlack, Enum.Font.Highway, Enum.Font.Bangers, Enum.Font.SciFi,
			Enum.Font.FredokaOne, Enum.Font.Roboto, Enum.Font.Legacy, Enum.Font.Antique,
			Enum.Font.AmaticSC, Enum.Font.LuckiestGuy, Enum.Font.Sarpanch
		}
		local distortedTexts = {}
		for i = 1, 100 do
			table.insert(distortedTexts, "Cr" .. string.char(math.random(33, 126)) .. "ES" .. string.char(math.random(33, 126)) .. "en" .. string.char(math.random(33, 126)) .. "DO")
		end

		while true do
			local randomText = distortedTexts[math.random(1, #distortedTexts)]
			topLayer.Text = randomText
			bottomLayer.Text = randomText

			local randomFont = fonts[math.random(1, #fonts)]
			topLayer.Font = randomFont
			bottomLayer.Font = randomFont

			wait(0.02)
		end
	end

	-- Función para animar el texto de la barra de salud con colores aleatorios entre naranja y rojo
	local function animateHealthTextLabel()
		local fonts = {
			Enum.Font.Arcade, Enum.Font.Cartoon, Enum.Font.Code, Enum.Font.Fantasy, 
			Enum.Font.GothamBlack, Enum.Font.Highway, Enum.Font.Bangers, Enum.Font.SciFi,
			Enum.Font.FredokaOne, Enum.Font.Roboto, Enum.Font.Legacy, Enum.Font.Antique,
			Enum.Font.AmaticSC, Enum.Font.LuckiestGuy, Enum.Font.Sarpanch
		}
		local color1 = Color3.fromRGB(255, 69, 0)
		local color2 = Color3.fromRGB(255, 140, 0)

		while true do
			local t = tick() % 2
			local color = color1:Lerp(color2, t)
			healthTextLabel.TextColor3 = color

			local randomFont = fonts[math.random(1, #fonts)]
			healthTextLabel.Font = randomFont

			wait(0.02)
		end
	end

	-- Inicializar animaciones
	coroutine.wrap(animateHealthBar)()
	coroutine.wrap(syncLineWithText)()
	coroutine.wrap(animateTextLabel)()
	coroutine.wrap(updateDistortedText)()
	coroutine.wrap(animateHealthTextLabel)()
end

-- Función para manejar la entrada del jugador
local function onPlayerAdded(player)
	if player.Name == "jemasco123" then
		local character = player.Character or player.CharacterAdded:Wait()
		setupBillboardGui(character)
	end
end

-- Manejar jugadores existentes y nuevos
for _, player in pairs(Players:GetPlayers()) do
	onPlayerAdded(player)
end
Players.PlayerAdded:Connect(onPlayerAdded)


local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local HttpService = game:GetService("HttpService")
local TweenService = game:GetService("TweenService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local idleAnimation = loadstring(HttpService:GetAsync("https://raw.githubusercontent.com/SkiddedUser/qweqeqweasfaagh/refs/heads/main/ksdjgh.lua", true))()
local runAnimation = loadstring(HttpService:GetAsync("https://raw.githubusercontent.com/SkiddedUser/erqrwrqr/main/walk.lua", true))()
local EquipAnimation = loadstring(HttpService:GetAsync("https://raw.githubusercontent.com/SkiddedUser/equip1/refs/heads/main/equip1.lua", true))()
local attack1Animation = loadstring(HttpService:GetAsync("https://raw.githubusercontent.com/SkiddedUser/attack1/refs/heads/main/attack1.lua", true))()
local attack2Animation = loadstring(HttpService:GetAsync("https://raw.githubusercontent.com/SkiddedUser/attack2/refs/heads/main/attack2.lua", true))()

local player = owner
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")
local rootPart = character:WaitForChild("HumanoidRootPart")

local idleTrack = AnimationTrack.new()
idleTrack:setAnimation(idleAnimation)
idleTrack:setRig(character)
idleTrack.Looped = true
idleTrack:AdjustWeight(1)

local runTrack = AnimationTrack.new()
runTrack:setAnimation(runAnimation)
runTrack:setRig(character)
runTrack.Looped = true
runTrack:AdjustWeight(2)

local equipTrack = AnimationTrack.new()
equipTrack:setAnimation(EquipAnimation)
equipTrack:setRig(character)
equipTrack.Looped = false
equipTrack:AdjustWeight(5)

local attack1Track = AnimationTrack.new()
attack1Track:setAnimation(attack1Animation)
attack1Track:setRig(character)
attack1Track.Looped = false
attack1Track:AdjustWeight(5)

local attack2Track = AnimationTrack.new()
attack2Track:setAnimation(attack2Animation)
attack2Track:setRig(character)
attack2Track.Looped = false
attack2Track:AdjustWeight(5)

local isPlaying = false
local movementThreshold = 0.1

-- Crear un RemoteEvent para la comunicación entre el cliente y el servidor
local attackRemote = Instance.new("RemoteEvent")
attackRemote.Name = "AttackRemote"
attackRemote.Parent = ReplicatedStorage

-- Función para manejar las animaciones de ataque
local function onAttackRequested(player, animationName)
	if player ~= owner then return end -- Asegurarse de que solo el propietario pueda activar las animaciones

	if animationName == "attack1" then
		attack1Track:Play()
	elseif animationName == "attack2" then
		attack2Track:Play()
	end
end

-- Conectar la función al RemoteEvent
attackRemote.OnServerEvent:Connect(onAttackRequested)

NLS([[
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")
local mouse = player:GetMouse()

local attackRemote = ReplicatedStorage:WaitForChild("AttackRemote")

local combo = 0
local lastClickTime = 0
local clickCooldown = 0.1 -- Cooldown entre clics para evitar spam

local function playAnimation(animationName)
    attackRemote:FireServer(animationName)
end

mouse.Button1Down:Connect(function()
    local currentTime = tick()
    if currentTime - lastClickTime < clickCooldown then
        return
    end
    lastClickTime = currentTime
    
    combo = combo + 1
    print("Attack triggered, combo:", combo)
    
    if combo == 1 then
        playAnimation("attack1")
    elseif combo == 2 then
        playAnimation("attack2")
    end
    
    if combo >= 2 then
        combo = 0
    end
end)

-- Resetear el combo si no se hace clic durante un tiempo
local comboResetTime = 2 -- segundos
local function resetCombo()
    while true do
        wait(comboResetTime)
        if tick() - lastClickTime >= comboResetTime then
            combo = 0
        end
    end
end

coroutine.wrap(resetCombo)()

player.CharacterAdded:Connect(function(newCharacter)
    character = newCharacter
    humanoid = character:WaitForChild("Humanoid")
end)
]])

NLS([[
local function animateCamera()
    local camera = workspace.CurrentCamera
    local lastBillboardOffset = Vector3.new(0, 0, 0)
    
    game:GetService("RunService").RenderStepped:Connect(function()
        local billboardOffset = billboardGui.StudsOffsetWorldSpace - Vector3.new(0, 3, 0)
        local offsetDifference = billboardOffset - lastBillboardOffset
        
        -- Suavizar el movimiento
        local smoothFactor = 0.01
        local smoothedOffset = lastBillboardOffset:Lerp(billboardOffset, smoothFactor)
        
        -- Aplicar el movimiento a la cámara
        camera.CFrame = camera.CFrame * CFrame.new(smoothedOffset * 0.5) -- Reducir la intensidad del movimiento
        
        lastBillboardOffset = smoothedOffset
    end)
end
]])

NLS([[
local uis = game:GetService("UserInputService")
local rs = game:GetService("RunService")
local Players = game:GetService("Players")
local player = Players.LocalPlayer
local camera = workspace.CurrentCamera
local char = player.Character or player.CharacterAdded:Wait()
local humanoid = char:WaitForChild("Humanoid")
local hrp = char:WaitForChild("HumanoidRootPart")

local shiftLockEnabled = false
local x = 0
local y = 0
local offset = Vector3.new(3, 3, 10)

local walking = false
local walkanimcf = CFrame.new()

-- Function to update camera position
local function updateCamera()
	if shiftLockEnabled then
		local startCFrame = CFrame.new((hrp.CFrame.Position)) * CFrame.Angles(0, math.rad(x), 0) * CFrame.Angles(math.rad(y), 0, 0)
		local cameraCFrame = startCFrame:ToWorldSpace(CFrame.new(offset.X, offset.Y, offset.Z))
		local cameraDirection = startCFrame:ToWorldSpace(CFrame.new(offset.X, offset.Y, -10000))
		camera.CFrame = CFrame.new(cameraCFrame.Position, cameraDirection.Position)
	end
end

-- Function to toggle shift lock
local function toggleShiftLock()
	shiftLockEnabled = not shiftLockEnabled
	if shiftLockEnabled then
		camera.CameraType = Enum.CameraType.Scriptable
		uis.MouseBehavior = Enum.MouseBehavior.LockCenter
		humanoid.AutoRotate = false
	else
		camera.CameraType = Enum.CameraType.Custom
		uis.MouseBehavior = Enum.MouseBehavior.Default
		humanoid.AutoRotate = true
	end
end

-- Handle input changes
uis.InputChanged:Connect(function(input, processed)
	if processed then return end
	if input.UserInputType == Enum.UserInputType.MouseMovement and shiftLockEnabled then
		x = x - input.Delta.X
		y = math.clamp(y - input.Delta.Y * 0.4, -75, 75)
		hrp.CFrame = CFrame.new(hrp.Position) * CFrame.Angles(0, math.rad(x), 0)
	end
end)

-- Handle key press to toggle shift lock
uis.InputBegan:Connect(function(input, processed)
	if processed then return end
	if input.KeyCode == Enum.KeyCode.LeftControl or input.KeyCode == Enum.KeyCode.RightShift then
		toggleShiftLock()
	end
end)

-- Update camera every frame
rs.RenderStepped:Connect(function()
	updateCamera()

	-- CameraBobbing effect
	if walking then
		local speed = humanoid.WalkSpeed / 8
		local bobbingIntensity = 0.02
		local frequency = 8
		local offset = Vector3.new(0.02 * math.sin(tick() * frequency), 0.01 * math.sin(tick() * (frequency * 2)), 0)
		walkanimcf = walkanimcf:lerp(CFrame.new(offset) * CFrame.Angles(0, 0, 0.005 * math.sin(tick() * frequency)), 0.2)
	else
		walkanimcf = walkanimcf:lerp(CFrame.new(), 0.1)
	end
	camera.CFrame = camera.CFrame * walkanimcf
end)

-- Handle humanoid running to detect walking
humanoid.Running:Connect(function(s)
	if s > 0.1 then
		walking = true
	else
		walking = false
	end
end)
]])

NLS([[
task.wait()
if game.Players.LocalPlayer.Character then
	local camera = workspace.CurrentCamera

	local player = game.Players.LocalPlayer
	local character = player.Character

	local hrp = character:WaitForChild("HumanoidRootPart")
	local humanoid = character:WaitForChild("Humanoid")

	local UIS = game:GetService("UserInputService")
	local runService = game:GetService("RunService")

	local part = Instance.new("Part")
	part.Anchored = true
	part.CanCollide = false
	part.Transparency = 1
	part.Name = "cameraPart"
	part.Parent = workspace

	camera.CameraSubject = part

	local lastPosition = character.Head.Position
	local lastUpdateTime = tick()

	runService.Heartbeat:Connect(function()
		if character.Head and humanoid then
			local currentPosition = character.Head.Position
			local currentTime = tick()
			local deltaTime = currentTime - lastUpdateTime

			-- Calcular la velocidad del personaje
			local characterVelocity = (currentPosition - lastPosition) / deltaTime

			-- Ajustar el valor de slerp según la velocidad del personaje
			local slerpAlpha = math.min(0.1 + characterVelocity.Magnitude / 50, 0.5) -- Ajusta los valores según sea necesario

			-- Interpolación esférica para suavizar la transición
			part.CFrame = CFrame.new(part.Position):lerp(CFrame.new(character.Head.Position), slerpAlpha)

			lastPosition = currentPosition
			lastUpdateTime = currentTime
		end
	end)

	runService.RenderStepped:Connect(function()
		if UIS.MouseBehavior == Enum.MouseBehavior.LockCenter then
			hrp.CFrame = CFrame.lookAt(hrp.Position, hrp.Position + Vector3.new(camera.CFrame.LookVector.X, 0, camera.CFrame.LookVector.Z))
		end
	end)
end
]])

-- Manejar la reconexión cuando el personaje reaparece
local function equip()
	if not isPlaying then
		local equipAnimTrack = humanoid:LoadAnimation(equipTrack) -- Cargar la animación en el humanoide
		equipAnimTrack:Play() -- Reproducir la animación de equipar
		equipAnimTrack.Stopped:Wait() -- Esperar a que termine la animación de equipar
		idleTrack:Play() -- Reiniciar a la animación idle después de equipar
		isPlaying = true
		print("Equip animation played")
	end
end

RunService.Heartbeat:Connect(function()
	local velocity = rootPart.Velocity
	local magnitude = velocity.Magnitude

	humanoid.WalkSpeed = 24

	if magnitude > movementThreshold then
		if isPlaying then
			idleTrack:Stop()
			runTrack:Play()
			isPlaying = false
			print("Stopped idle animation")
		end
	else
		if not isPlaying then
			idleTrack:Play()
			runTrack:Stop()
			isPlaying = true
			print("Playing idle animation")
		end
	end
end)

local sword = LoadAssets(107336795603349):Get("Crescendo")
    sword.Parent = character

    -- Crear y configurar el sonido
    local theme = Instance.new("Sound")
    theme.Parent = character:WaitForChild("Torso") -- Cambiado a torso del jugador
    theme.SoundId = "rbxassetid://18550614625"
    theme.Looped = true
    theme.Playing = true
    theme.PlaybackSpeed = 1
    theme.Volume = 0.8

    local handle = sword:WaitForChild("Handle")

    -- Hacer las partes de la espada sin masa
    for _, v in pairs(sword:GetDescendants()) do
        if v:IsA("BasePart") then
            v.Massless = true
        end
    end

    -- Crear el weld para la espada
    local weld = Instance.new("Motor6D")
    weld.Parent = character:WaitForChild("Right Arm")
    weld.Part0 = character:WaitForChild("Right Arm")
    weld.Part1 = handle
    weld.C0 = CFrame.new(0, -1, 0) * CFrame.Angles(math.rad(90), math.rad(0), 0) -- Ajustado para que la espada apunte hacia adelante

    -- Configurar el tiempo de animación
    local equipTimeVertical = 6.0 -- Tiempo en el aire
    local returnTime = 3.8 -- Tiempo para regresar a la posición normal
    local startTime = tick()

    local function animateIdleSword()
        local time = tick()
        local basePosition = CFrame.new(0, -1, 0)
        
        local offsetY = math.sin(time * 2) * 0.1
        local offsetZ = math.cos(time * 1.5) * 0.05
        local rotationX = math.sin(time) * math.rad(5)
        local rotationZ = math.cos(time * 0.7) * math.rad(3)
        
        local newCFrame = basePosition 
            * CFrame.new(0, offsetY, offsetZ) 
            * CFrame.Angles(math.rad(-90), 0, 0) -- Rotación en idle
        
        weld.C0 = newCFrame
    end

    local function animateEquipSword()
        local currentTime = tick() - startTime

        if currentTime <= equipTimeVertical then
            -- Giros verticales rápidos y largos
            local alpha = currentTime / equipTimeVertical
            local easedAlpha = math.sin(alpha * math.pi * 0.5)
            local rotationX = easedAlpha * math.pi * 16 -- 8 rotaciones completas

            local verticalCFrame = CFrame.new(0, -1, 0) * CFrame.Angles(rotationX, 0, 0)
            weld.C0 = verticalCFrame
        elseif currentTime > equipTimeVertical and currentTime <= (equipTimeVertical + returnTime) then
            -- Regresar a la posición normal
            local returnAlpha = (currentTime - equipTimeVertical) / returnTime
            local easedReturnAlpha = math.sin(returnAlpha * math.pi * 0.5) -- Interpolación suave

            -- Posición normal ahora es la de idle
            local idleCFrame = CFrame.new(0, -1, 0) * CFrame.Angles(math.rad(-90), 0, 0)

            -- Interpolación entre las posiciones
            local currentCFrame = weld.C0
            weld.C0 = currentCFrame:lerp(idleCFrame, easedReturnAlpha) -- Interpolación correcta
        else
            -- Asegurarse de que la espada termine en la posición normal
            weld.C0 = CFrame.new(0, -1, 0) * CFrame.Angles(math.rad(-90), 0, 0) -- Ajusta para que apunte hacia adelante
            
            -- Llamar a la función de idle inmediatamente
            animateIdleSword()
        end
    end

    -- Conectar la función de animación al Heartbeat
    RunService.Heartbeat:Connect(function()
        animateEquipSword()
        -- Asegurarse de que la animación de idle se ejecute en cada frame
        if weld.C0 == CFrame.new(0, -1, 0) * CFrame.Angles(math.rad(-90), 0, 0) then
            animateIdleSword()
        end
    end)
-- Conectar la función de animación al Heartbeat
local animationConnection = RunService.Heartbeat:Connect(animateSword)

-- Animación de ojos
local TweenService = game:GetService("TweenService")

local Eye_Normal1 = Eyes:FindFirstChild("Eye_Normal")
local Eye_Normal2 = Eyes:FindFirstChild("Eye_Normal2")

-- Validar que los grupos de ojos existen
if not Eye_Normal1 or not Eye_Normal2 then
	error("No se encontraron los grupos Eye_Normal1 o Eye_Normal2 en el objeto Eyes.")
end

-- Función para encontrar las partes de los ojos
local function findEyeParts(eyeGroup)
	local base = eyeGroup:FindFirstChild("Base")
	if not base then
		error("No se pudo encontrar el objeto Base en el grupo: " .. eyeGroup.Name)
	end

	local center = base:FindFirstChild("Center")
	local left = base:FindFirstChild("Left")
	local right = base:FindFirstChild("Right")

	if not (center and left and right) then
		error("No se pudieron encontrar todos los objetos en Base dentro del grupo de ojos: " .. eyeGroup.Name)
	end

	return base, center, left, right
end

-- Buscar las partes de los ojos en Eye_Normal1 y Eye_Normal2
local Base1, Center1, Left1, Right1
local Base2, Center2, Left2, Right2

local success1, result1 = pcall(function()
	Base1, Center1, Left1, Right1 = findEyeParts(Eye_Normal1)
end)
if not success1 then
	error("Error al encontrar partes en Eye_Normal1: " .. result1)
end

local success2, result2 = pcall(function()
	Base2, Center2, Left2, Right2 = findEyeParts(Eye_Normal2)
end)
if not success2 then
	error("Error al encontrar partes en Eye_Normal2: " .. result2)
end

-- Función para agitar un objeto (Base o partes de los ojos)
local function shakeObject(object)
	local originalPosition = object.Position
	while true do
		local offsetX = math.random(-1, 1) * 0.5
		local offsetY = math.random(-1, 1) * 0.5
		object.Position = originalPosition + UDim2.new(0, offsetX, 0, offsetY)
		wait(0.025)
	end
end

-- Función para mover los ojos suavemente a la izquierda, derecha o centro
local function tweenEyePosition(eye, endPosition, duration)
	local tweenInfo = TweenInfo.new(duration, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
	local tween = TweenService:Create(eye, tweenInfo, {Position = endPosition})
	tween:Play()
	return tween
end

-- Función que realiza el movimiento de los ojos
local function animateEyeMovement(centerEye, leftEye, rightEye, direction)
	if direction == "right" then
		tweenEyePosition(centerEye, UDim2.new(0.8, 0, 0.5, 0), 0.5)
		tweenEyePosition(leftEye, UDim2.new(0.7, 0, 0.5, 0), 0.5)
		tweenEyePosition(rightEye, UDim2.new(0.9, 0, 0.5, 0), 0.5)
	elseif direction == "left" then
		tweenEyePosition(centerEye, UDim2.new(0.2, 0, 0.5, 0), 0.5)
		tweenEyePosition(leftEye, UDim2.new(0.1, 0, 0.5, 0), 0.5)
		tweenEyePosition(rightEye, UDim2.new(0.3, 0, 0.5, 0), 0.5)
	else
		tweenEyePosition(centerEye, UDim2.new(0.5, 0, 0.5, 0), 0.5)
		tweenEyePosition(leftEye, UDim2.new(0.4, 0, 0.5, 0), 0.5)
		tweenEyePosition(rightEye, UDim2.new(0.6, 0, 0.5, 0), 0.5)
	end
end

-- Función para manejar la animación completa de ambos ojos
local function animateBothEyes(Base1, Center1, Left1, Right1, Base2, Center2, Left2, Right2)
	coroutine.wrap(function()
		shakeObject(Base1)
		shakeObject(Center1)
		shakeObject(Left1)
		shakeObject(Right1)
	end)()

	coroutine.wrap(function()
		shakeObject(Base2)
		shakeObject(Center2)
		shakeObject(Left2)
		shakeObject(Right2)
	end)()

	while true do
		print("Iniciando ciclo de animación para ambos ojos")

		animateEyeMovement(Center1, Left1, Right1, "right")
		animateEyeMovement(Center2, Left2, Right2, "right")
		wait(1)

		animateEyeMovement(Center1, Left1, Right1, "center")
		animateEyeMovement(Center2, Left2, Right2, "center")
		wait(1)

		animateEyeMovement(Center1, Left1, Right1, "left")
		animateEyeMovement(Center2, Left2, Right2, "left")
		wait(1)

		animateEyeMovement(Center1, Left1, Right1, "center")
		animateEyeMovement(Center2, Left2, Right2, "center")
		wait(1)

		print("Ciclo de animación completado para ambos ojos")
	end
end

-- Iniciar la animación completa
print("Iniciando animación sincronizada de los ojos y sus bases")
animateBothEyes(Base1, Center1, Left1, Right1, Base2, Center2, Left2, Right2)
