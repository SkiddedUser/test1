--[[
  CREDITS TO MECHXYZ
	mech's anitracker
	i know i suck at names

	how to use:
	1. create a new track with AnimationTrack.new()
	2. anim:setAnimation(url or table)
	3. anim:setRig(rig)
	4. anim:Play()

	- AdjustWeight doesn't actually adjust weight, it adjusts priority (i thought weights and priority were the same thing a while back)
	- set anim.lerpFactor to change how much it lerps into the next pose
	- AnimationTrack.NoDisableTransition is global and sets whether the welds lerp into their parent's Transform after all animations on a rig are done playing before being disabled, setting it to false disables the welds as soon as the last animation stops
	- welds generated by anitracker are named "AWeld" with an attribute called AnitrackerEnabled set to true, disable the welds before setting the attribute to false
	- can also be used on client
]]

local AnimationTrack
local twait = task.wait
local http = game:GetService("HttpService")
local tween = game:GetService("TweenService")

do
	AnimationTrack = {}
	AnimationTrack.Rigs = {}
	AnimationTrack.Speed = 1
	AnimationTrack.Stall = 0
	AnimationTrack.Length = 0
	AnimationTrack.Weight = 1
	AnimationTrack.Looped = false
	AnimationTrack.RealWeight = 1
	AnimationTrack.lerpFactor = .6
	AnimationTrack.TimePosition = 0
	AnimationTrack.IsPlaying = false
	AnimationTrack.__index = AnimationTrack
	AnimationTrack.NoDisableTransition = false

	local function enumExists(type, value)
		return pcall(function()
			return Enum[type][value] ~= nil
		end)
	end

	function AnimationTrack.Destroy(self)
		if not self then
			return
		end

		if self.Connections then
			for _, v in pairs(self.Connections) do
				v:Disconnect()
			end

			table.clear(self.Connections)
		end

		if self.Binds then
			for _, v in pairs(self.Binds) do
				v:Destroy()
			end

			table.clear(self.Binds)
		end

		table.clear(self.Cache)
		table.clear(self.Used)
		self.StopBind:Destroy()
		self.StopBind = nil

		local stuff = AnimationTrack.Rigs[self.Rig]

		if stuff then
			for i, v in pairs(stuff.Animations) do
				if v == self then
					stuff.Animations[i] = nil
					break
				end
			end
		end

		table.clear(self)
		self = nil
	end

	function AnimationTrack.new()
		local be = Instance.new("BindableEvent", script)

		local track = setmetatable({}, AnimationTrack)
		track.Rigs = nil

		track.Used = {}
		track.Cache = {}
		track.Binds = {}
		track.StopBind = be
		track.Connections = {}
		track.Stopped = be.Event
		track.KeyframeMarkers = {}
		track.Identifier = http:GenerateGUID()

		return track
	end

	function AnimationTrack.GetMarkerReachedSignal(self, marker)
		if not self.Binds[marker] then
			local be = Instance.new("BindableEvent")
			self.Binds[marker] = be
		end

		return self.Binds[marker].Event
	end

	function AnimationTrack.GetKeyframeReachedSignal(self, keyframe)
		if typeof(keyframe) == "number" then
			local num = keyframe
			keyframe = self.Animation[num]
			assert(keyframe, string.format("Keyframe #%d does not exist!", num))
		end

		assert(table.find(self.Animation, keyframe), "Keyframe does not exist!")

		if not self.Binds[keyframe] then
			local be = Instance.new("BindableEvent")
			self.Binds[keyframe] = be
		end

		return self.Binds[keyframe].Event
	end

	function AnimationTrack.AdjustWeight(self, weight)
		self.RealWeight = weight
		self.Weight = self.RealWeight
	end

	function AnimationTrack.addWeld(self, motor)
		local weld = motor:FindFirstChild("AWeld")

		if not weld then
			weld = Instance.new("Weld", motor)
			weld.C0 = motor.C0
			weld.C1 = motor.C1
			weld.Name = "AWeld"
			weld.Part0 = motor.Part0
			weld.Part1 = motor.Part1
		end

		weld:SetAttribute("AnitrackerEnabled", true)

		AnimationTrack.Rigs[self.Rig].Welds[motor.Part1.Name] = weld
		AnimationTrack.Rigs[self.Rig].Poses[motor.Part1.Name] = CFrame.new()
	end

	function AnimationTrack.setRig(self, rig)
		assert(self.Animation, "Must set Animation before setting Rig!")

		self.Rig = rig

		-- // funny variable name
		local boner = rig:FindFirstChild("InitialPoses")

		if boner then
			local root = rig:FindFirstChildWhichIsA("Bone", true):FindFirstAncestorWhichIsA("BasePart")

			if not root then
				boner = nil
				return
			end

			for _, v in pairs(boner:GetChildren()) do
				if string.find(v.Name, "_Initial") then
					repeat
						local bone = root:FindFirstChild(string.gsub(v.Name, "_Initial", ""), true)

						if not bone then
							break
						end

						bone:SetAttribute("Initial", v.Value)
					until true
				end
			end
		end

		if not AnimationTrack.Rigs[rig] then
			AnimationTrack.Rigs[rig] = {
				Poses = {},
				Welds = {},
				Animations = {self}
			}

			local animate

			animate = game:GetService("RunService").PreAnimation:Connect(function()
				if not AnimationTrack.Rigs[rig] then
					animate:Disconnect()
				end

				local allDone = true
				local usedJoints = {}

				for _, v in pairs(AnimationTrack.Rigs[rig].Animations) do
					if v.IsPlaying then
						allDone = false

						for i in pairs(v.Used) do
							usedJoints[i] = true
						end
					end
				end

				if not boner then
					for i, v in pairs(AnimationTrack.Rigs[rig].Welds) do
						repeat
							if not v.Parent then
								AnimationTrack.Rigs[rig].Welds[i] = nil
								break
							end

							local offset = AnimationTrack.Rigs[rig].Poses[i]
							offset = CFrame.new(offset.Position * rig:GetScale()) * CFrame.Angles(offset:ToEulerAnglesXYZ())

							if not allDone and usedJoints[i] then
								v.Enabled = v:GetAttribute("AnitrackerEnabled")
								v.C0 = v.Parent.C0 * offset
							elseif allDone or not usedJoints[i] then
								if not self.NoDisableTransition then
									v.C0 = v.C0:Lerp(v.Parent.C0 * v.Parent.Transform, self.lerpFactor)

									if (v.C0.Position - (v.Parent.C0 * v.Parent.Transform).Position).Magnitude <= .2 then
										v.Enabled = false

										if AnimationTrack.Rigs[self.Rig] then
											AnimationTrack.Rigs[self.Rig].Poses[i] = CFrame.new()
										end
									end
								else
									v.Enabled = false

									if AnimationTrack.Rigs[self.Rig] then
										AnimationTrack.Rigs[self.Rig].Poses[i] = v.Parent.Transform
									end
								end
							end
						until true
					end
				else
					for i, v in pairs(AnimationTrack.Rigs[rig].Welds) do
						repeat
							if not v:GetAttribute("Initial") then
								AnimationTrack.Rigs[rig].Welds[i] = nil
								break
							end

							if not allDone then
								v.CFrame = v:GetAttribute("Initial") * AnimationTrack.Rigs[rig].Poses[i]
							else
								v.CFrame = v:GetAttribute("Initial")

								if AnimationTrack.Rigs[self.Rig] then
									AnimationTrack.Rigs[self.Rig].Poses[i] = CFrame.new()
								end
							end
						until true
					end
				end
			end)

			local adder

			adder = rig.DescendantAdded:Connect(function(v)
				if not AnimationTrack.Rigs[rig] then
					adder:Disconnect()
				end

				if v:IsA("Motor6D") then
					self:addWeld(v)
				end
			end)

			AnimationTrack.Rigs[rig].Adder = adder
			AnimationTrack.Rigs[rig].Animate = animate
		else
			table.insert(AnimationTrack.Rigs[rig].Animations, self)
		end

		for _, v in pairs(rig:GetDescendants()) do
			repeat
				if boner and v:IsA("Bone") and self.Used[v.Name] then
					AnimationTrack.Rigs[rig].Welds[v.Name] = v
					AnimationTrack.Rigs[rig].Poses[v.Name] = CFrame.new()

					break
				end

				if v:IsA("Motor6D") and self.Used[v.Part1.Name] then
					self:addWeld(v)
				end
			until true
		end

		coroutine.wrap(function()
			repeat
				twait()
			until rig.Parent

			rig.Parent.ChildRemoved:Connect(function(v)
				if v == rig then
					AnimationTrack.Rigs[rig] = nil
					self:Destroy()
				end
			end)
		end)()
	end

	function AnimationTrack.getMotor(self, name)
		if self.Cache[name] then
			return self.Cache[name]
		end

		for _, v in pairs(self.Rig:GetDescendants()) do
			if v:IsA("Motor6D") and v.Part1.Name == name then
				self.Cache[name] = v
				return v
			end
		end
	end

	function AnimationTrack.setAnimation(self, anim)
		local length = 0

		if typeof(anim) == "string" then
			if game:GetService("RunService"):IsClient() then
				error("You must be on server to pass urls to setAnimation!")
			end

			anim = loadstring(http:GetAsync(anim))()
		end

		self.Animation = anim

		local found = {}

		for i, v in pairs(anim) do
			if v.tm > length then
				length = v.tm
			end

			for j, w in pairs(v) do
				repeat
					if typeof(w) ~= "table" then
						if typeof(w) == "string" then
							table.insert(self.KeyframeMarkers, {
								Name = j,
								Value = w,
								Time = v.tm
							})
						end

						break
					end

					found[j] = true
					self.Used[j] = true

					-- // taken from replay
					local o = 1

					while true do
						local next = anim[i + o]

						if next and next[j] then
							w.nx = i + o
							break
						end

						o = o + 1

						if o >= #(anim) then
							break
						end
					end
				until true
			end
		end

		self.Length = length
	end

	function AnimationTrack.IsPrioritized(self, j)
		if not AnimationTrack.Rigs[self.Rig] then
			return
		end

		if not AnimationTrack.Rigs[self.Rig].Animations then
			return
		end

		local highest = 0
		local prioritized

		for _, v in pairs(AnimationTrack.Rigs[self.Rig].Animations) do
			if v.Weight > highest and v.IsPlaying then
				prioritized = v
				highest = v.Weight
			end
		end

		if prioritized == self then
			return true
		elseif prioritized ~= self and prioritized then
			if not prioritized.Used[j] then
				local second
				local highest = 0

				for _, v in pairs(AnimationTrack.Rigs[self.Rig].Animations) do
					if v.Weight > highest and v.IsPlaying and v ~= prioritized then
						second = v
						highest = v.Weight
					end
				end

				return second == self
			end
		end
	end

	function AnimationTrack.setCFrame(self, name, cf, info)
		local weld = AnimationTrack.Rigs[self.Rig].Welds[name]
		local poses = AnimationTrack.Rigs[self.Rig].Poses

		if not info then
			AnimationTrack.Rigs[self.Rig].Poses[name] = cf
			weld.C0 = weld.Parent.C0 * cf
		else
			local start = tick()

			while (tick() - start) < info.Time and AnimationTrack.Rigs[self.Rig] and AnimationTrack.Rigs[self.Rig].Poses do
				poses[name] = poses[name]:Lerp(
					cf,
					tween:GetValue((tick() - start) / info.Time, info.EasingStyle, info.EasingDirection)
				)

				weld.C0 = weld.Parent.C0 * poses[name]
				twait()
			end
		end
	end

	function AnimationTrack.goToKeyframe(self, v, inst)
		local speed = self.Speed

		if self.Binds[v] then
			self.Binds[v]:Fire()
		end

		for j, w in pairs(v) do
			local br = false

			repeat
				if typeof(w) ~= "table" or not AnimationTrack.Rigs[self.Rig].Poses[j] then
					if typeof(w) == "string" and self.Binds[j] then
						self.Binds[j]:Fire(w)
					end

					break
				end

				if not AnimationTrack.Rigs[self.Rig].Animations then
					br = true
					break
				end

				local tm = 0
				local nx = w.nx
				local cf = w.cf

				if nx then
					cf = self.Animation[w.nx][j].cf
					tm = self.Animation[w.nx].tm - v.tm
				end

				if self:IsPrioritized(j) and (w.es == "Constant" or inst) then
					if inst and self:IsPrioritized(j) then
						AnimationTrack.Rigs[self.Rig].Poses[j] = cf
						break
					end

					local start = tick()

					coroutine.wrap(function()
						repeat
							AnimationTrack.Rigs[self.Rig].Poses[j] = cf
							twait()
						until tick() - start >= (tm / speed)
					end)()

					break
				end

				if not enumExists("EasingStyle", w.es) then
					w.es = "Linear"
				end

				coroutine.wrap(function()
					local s = tick()
					local current = AnimationTrack.Rigs[self.Rig].Poses[j]

					repeat
						twait()

						local cf = current:Lerp(cf, tween:GetValue(
							(tick() - s) / (tm / speed),
							Enum.EasingStyle[w.es],
							Enum.EasingDirection[w.ed]
							))

						if self:IsPrioritized(j) then
							AnimationTrack.Rigs[self.Rig].Poses[j] = AnimationTrack.Rigs[self.Rig].Poses[j]:Lerp(cf, math.min(self.lerpFactor * math.max(1, speed), 1))
						end
					until (tick() - s) >= (tm / speed)
				end)()
			until true

			if br then
				break
			end
		end
	end

	function AnimationTrack.Play(self, speed)
		assert(self.Rig, "Must use setRig before playing!")

		speed = speed or self.Speed

		if self.IsPlaying then
			for _, v in pairs(self.Connections) do
				v:Disconnect()
			end
		end

		self.Speed = speed
		self.IsPlaying = true
		self.Weight = self.RealWeight

		self.TimePosition = 0

		-- // just loop through all the keyframes instantly if speed is too high since it'll break
		if false then
			coroutine.wrap(function()
				repeat
					twait()

					for _, v in ipairs(self.Animation) do
						self:goToKeyframe(v, true)
						self.TimePosition = self.TimePosition + v.tm
					end

					self.TimePosition = self.Length
					task.wait(self.Stall)
				until not self.Looped

				self:Stop()
			end)()

			return
		end

		coroutine.wrap(function()
			repeat
				self.TimePosition = 0

				for _, v in ipairs(self.Animation) do
					local cnt
					local total = 0
					local time = v.tm

					cnt = game:GetService("RunService").PreAnimation:Connect(function(dt)
						total = total + dt * self.Speed

						if total >= time then
							cnt:Disconnect()
							self:goToKeyframe(v)
						end
					end)

					table.insert(self.Connections, cnt)
				end

				repeat
					self.TimePosition = self.TimePosition + twait() * self.Speed
				until self.TimePosition >= (self.Length + (self.Looped and 0 or self.Stall)) or not self.IsPlaying

				if self.TimePosition >= self.Length and not self.Looped then
					self:Stop()
				end
			until not self.Looped or not self.IsPlaying
		end)()
	end

	function AnimationTrack.Stop(self)
		if not self.IsPlaying then
			return
		end

		self.StopBind:Fire()

		self.Weight = 0
		self.IsPlaying = false

		if self.Connections then
			for _, cnt in pairs(self.Connections) do
				cnt:Disconnect()
			end
		end
	end

	function AnimationTrack.AdjustSpeed(self, speed)
		self.Speed = speed or 1
	end
end

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local HttpService = game:GetService("HttpService")
local TweenService = game:GetService("TweenService")

local idleAnimation = loadstring(HttpService:GetAsync("https://raw.githubusercontent.com/SkiddedUser/erereerer/main/rereeree.lua", true))()
local runAnimation = loadstring(HttpService:GetAsync("https://raw.githubusercontent.com/SkiddedUser/erqrwrqr/main/walk.lua", true))()

local attack1Animation = loadstring(HttpService:GetAsync("https://raw.githubusercontent.com/dukapanzer/void-scripts/main/Neptunian_Attack1.lua", true))()
local attack2Animation = loadstring(HttpService:GetAsync("https://raw.githubusercontent.com/dukapanzer/void-scripts/main/Neptunian_Attack2.lua", true))()

local player = owner
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")
local rootPart = character:WaitForChild("HumanoidRootPart")

local idleTrack = AnimationTrack.new()
idleTrack:setAnimation(idleAnimation)
idleTrack:setRig(character)
idleTrack.Looped = true
idleTrack:AdjustWeight(1)

local runTrack = AnimationTrack.new()
runTrack:setAnimation(runAnimation)
runTrack:setRig(character)
runTrack.Looped = true
runTrack:AdjustWeight(2)

local attack1Track = AnimationTrack.new()
attack1Track:setAnimation(attack1Animation)
attack1Track:setRig(character)
attack1Track.Looped = false
attack1Track:AdjustWeight(5)

local attack2Track = AnimationTrack.new()
attack2Track:setAnimation(attack2Animation)
attack2Track:setRig(character)
attack2Track.Looped = false
attack2Track:AdjustWeight(5)

local isPlaying = false
local movementThreshold = 0.1

NLS([[
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")
local mouse = player:GetMouse()

local combo = 0
local lastClickTime = 0
local clickCooldown = 0.1 -- Cooldown entre clics para evitar spam

local function playAnimation(animationName)
    local event = Instance.new("BindableEvent")
    event.Name = "PlayAnimation"
    event.Parent = ReplicatedStorage
    event:Fire(animationName)
    event:Destroy()
end

mouse.Button1Down:Connect(function()
    local currentTime = tick()
    if currentTime - lastClickTime < clickCooldown then
        return
    end
    lastClickTime = currentTime

    combo = combo + 1
    print("Attack triggered, combo:", combo)

    if combo == 1 then
        playAnimation("attack1")
    elseif combo == 2 then
        playAnimation("attack2")
    end

    if combo >= 2 then
        combo = 0
    end
end)

-- Resetear el combo si no se hace clic durante un tiempo
local comboResetTime = 2 -- segundos
local function resetCombo()
    while true do
        wait(comboResetTime)
        if tick() - lastClickTime >= comboResetTime then
            combo = 0
        end
    end
end
coroutine.wrap(resetCombo)()

player.CharacterAdded:Connect(function(newCharacter)
    character = newCharacter
    humanoid = character:WaitForChild("Humanoid")
end)
]])

local function onAnimationRequested(animationName)
    if animationName == "attack1" then
        attack1Track:Play()
    elseif animationName == "attack2" then
        attack2Track:Play()
    end
end

local function setupAnimationListener()
    local event = ReplicatedStorage:WaitForChild("PlayAnimation", 10)
    if event then
        event.Event:Connect(onAnimationRequested)
    end
end

setupAnimationListener()

player.CharacterAdded:Connect(function(newCharacter)
    character = newCharacter
    humanoid = character:WaitForChild("Humanoid")
    rootPart = character:WaitForChild("HumanoidRootPart")
    
    idleTrack:setRig(character)
    runTrack:setRig(character)
    attack1Track:setRig(character)
    attack2Track:setRig(character)
    
    setupAnimationListener()
end)
local sword = LoadAssets(107336795603349):Get("Crescendo")
sword.Parent = character

local handle = sword:WaitForChild("Handle")

-- Configurar el sonido
local theme = Instance.new("Sound")
theme.Parent = character:WaitForChild("Torso")
theme.SoundId = "rbxassetid://18550614625"
theme.Looped = true
theme.Playing = true
theme.PlaybackSpeed = 1
theme.Volume = 0.8

-- Hacer las partes de la espada sin masa
for _, v in pairs(sword:GetDescendants()) do
	if v:IsA("BasePart") then
		v.Massless = true
	end
end

-- Crear el weld para la espada
local weld = Instance.new("Motor6D")
weld.Parent = character:WaitForChild("Right Arm")
weld.Part0 = character:WaitForChild("Right Arm")
weld.Part1 = handle
weld.C0 = CFrame.new(0, -1, 0) * CFrame.Angles(math.rad(90), math.rad(180), 0)

RunService.Heartbeat:Connect(function()
	local velocity = rootPart.Velocity
	local magnitude = velocity.Magnitude

	humanoid.WalkSpeed = 24

	if magnitude > movementThreshold then
		if isPlaying then
			idleTrack:Stop()
			runTrack:Play()
			isPlaying = false
			print("Stopped idle animation")
		end
	else
		if not isPlaying then
			idleTrack:Play()
			runTrack:Stop()
			isPlaying = true
			print("Playing idle animation")
		end
	end
end)

print("Script de la espada Crescendo cargado y ejecutándose")

local Eyes = sword:FindFirstChild("Handle"):FindFirstChild("Crescendo"):FindFirstChild("Eyes")
local Eye_Normal1 = Eyes:FindFirstChild("Eye_Normal")
local Eye_Normal2 = Eyes:FindFirstChild("Eye_Normal2")

-- Validar que los grupos de ojos existen
if not Eye_Normal1 or not Eye_Normal2 then
	error("No se encontraron los grupos Eye_Normal1 o Eye_Normal2 en el objeto Eyes.")
end

-- Función para encontrar las partes de los ojos
local function findEyeParts(eyeGroup)
	local base = eyeGroup:FindFirstChild("Base")
	if not base then
		error("No se pudo encontrar el objeto Base en el grupo: " .. eyeGroup.Name)
	end

	local center = base:FindFirstChild("Center")
	local left = base:FindFirstChild("Left")
	local right = base:FindFirstChild("Right")

	if not (center and left and right) then
		error("No se pudieron encontrar todos los objetos en Base dentro del grupo de ojos: " .. eyeGroup.Name)
	end

	return base, center, left, right
end

-- Buscar las partes de los ojos en Eye_Normal1 y Eye_Normal2
local Base1, Center1, Left1, Right1
local Base2, Center2, Left2, Right2

-- Manejar posibles errores en la búsqueda de partes
local success1, result1 = pcall(function()
	Base1, Center1, Left1, Right1 = findEyeParts(Eye_Normal1)
end)
if not success1 then
	error("Error al encontrar partes en Eye_Normal1: " .. result1)
end

local success2, result2 = pcall(function()
	Base2, Center2, Left2, Right2 = findEyeParts(Eye_Normal2)
end)
if not success2 then
	error("Error al encontrar partes en Eye_Normal2: " .. result2)
end

-- Función para agitar un objeto (Base o partes de los ojos)
local function shakeObject(object)
	local originalPosition = object.Position
	while true do
		local offsetX = math.random(-1, 0.7) * 1
		local offsetY = math.random(-1, 0.7) * 1
		object.Position = originalPosition + UDim2.new(0, offsetX, 0, offsetY)
		wait(0.025)
	end
end

-- Función para mover los ojos suavemente a la izquierda, derecha o centro
local function tweenEyePosition(eye, endPosition, duration)
	local tweenInfo = TweenInfo.new(duration, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
	local tween = TweenService:Create(eye, tweenInfo, {Position = endPosition})
	tween:Play()
	return tween
end

-- Función que realiza el movimiento de los ojos
local function animateEyeMovement(centerEye, leftEye, rightEye, direction)
	if direction == "right" then
		-- Mover hacia la derecha
		tweenEyePosition(centerEye, UDim2.new(0.8, 0, 0.5, 0), 0.5)
		tweenEyePosition(leftEye, UDim2.new(0.7, 0, 0.5, 0), 0.5)
		tweenEyePosition(rightEye, UDim2.new(0.9, 0, 0.5, 0), 0.5)
	elseif direction == "left" then
		-- Mover hacia la izquierda
		tweenEyePosition(centerEye, UDim2.new(0.2, 0, 0.5, 0), 0.5)
		tweenEyePosition(leftEye, UDim2.new(0.1, 0, 0.5, 0), 0.5)
		tweenEyePosition(rightEye, UDim2.new(0.3, 0, 0.5, 0), 0.5)
	else
		-- Volver al centro
		tweenEyePosition(centerEye, UDim2.new(0.5, 0, 0.5, 0), 0.5)
		tweenEyePosition(leftEye, UDim2.new(0.4, 0, 0.5, 0), 0.5)
		tweenEyePosition(rightEye, UDim2.new(0.6, 0, 0.5, 0), 0.5)
	end
end

-- Función para manejar la animación completa de ambos ojos
local function animateBothEyes(Base1, Center1, Left1, Right1, Base2, Center2, Left2, Right2)
	-- Agitar los ojos y las bases con la función original de agitación
	coroutine.wrap(function()
		shakeObject(Base1)
		shakeObject(Center1)
		shakeObject(Left1)
		shakeObject(Right1)
	end)()

	coroutine.wrap(function()
		shakeObject(Base2)
		shakeObject(Center2)
		shakeObject(Left2)
		shakeObject(Right2)
	end)()

	while true do
		print("Iniciando ciclo de animación para ambos ojos")

		-- Movimiento hacia la derecha
		animateEyeMovement(Center1, Left1, Right1, "right")
		animateEyeMovement(Center2, Left2, Right2, "right")
		wait(1)

		-- Volver al centro
		animateEyeMovement(Center1, Left1, Right1, "center")
		animateEyeMovement(Center2, Left2, Right2, "center")
		wait(1)

		-- Movimiento hacia la izquierda
		animateEyeMovement(Center1, Left1, Right1, "left")
		animateEyeMovement(Center2, Left2, Right2, "left")
		wait(1)

		-- Volver al centro
		animateEyeMovement(Center1, Left1, Right1, "center")
		animateEyeMovement(Center2, Left2, Right2, "center")
		wait(1)

		print("Ciclo de animación completado para ambos ojos")
	end
end

-- Iniciar la animación completa
print("Iniciando animación sincronizada de los ojos y sus bases")
animateBothEyes(Base1, Center1, Left1, Right1, Base2, Center2, Left2, Right2)
